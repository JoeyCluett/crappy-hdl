//
// HDL - Hardware Description Language
//
// digital circuits
//
// a and (b or c)
//

requires adders; // file to import

global CpuWidth     : integer = 32;
global AddressWidth : integer = 16;
global ResetActive  : integer =  0; // active low reset

global GlString : string = "hi\s\s\s\s\sspaces";

//
//module FancyNewModule
//    out_ports: AddressBus[global.AddressWidth], DataOut[global.CpuWidth];
//
//    in_ports: DataIn[0x0000_0020], MemReady;
//start
//    // nothing in the body
//    // this is the simplest module possible
//
//    
//
//end
//
//module TopLevelCpu
//    header = empty;
//start
//
//
//
//    // body of module definition
//end
//


module SignExtend(in_width : integer, out_width : integer)
    in_ports: InPort[in_width];
    out_ports: OutPort[out_width];
start

    assert(out_width >= in_width, "out_width must be greater than or equal to in_width");
    assert(in_width > 0, "in_width must be greater than 0");

    //for range(i : integer; 0, in_width) { OutPort[i] = InPort[i]; } // these two lines do the same thing

    OutPort[{        0 ;  in_width }] = InPort[{ 0 : in_width }]; // many-to-many, matching sizes
    OutPort[{ in_width ; out_width }] = InPort[$];                // one-to-many, '$' is shorthand for 'last element'

end

module TestBench_SignExtend
    header=empty;
start

    //
    // test 10-to-15 bit sign extension
    //
    local SignExtend se(10, 15);

    local i : integer = length(se.InPort);

    se.InPort[*]                = '0b10_0000_0000';
    simulate(); //                   |
    assert(se.OutPort[*] == '0b111_1110_0000_0000');

    local i : integer = cycles(); // cycles() returns the most recent number of simulation cycles the last simulation took to settle

    se.InPort[*]                = @'0b00_0000_0000';
    simulate(); //                      |
    assert(se.OutPort[*] == @'0b000_0000_0000_0000');

    clear $; // clears netlist
    clear *; // clears all local variables (variables in current scope)

    //
    // test 1-to-32 bit sign extension
    //
    local SignExtend se(1, 8);

    se.InPort[*] = @"1";
    simulate();
    assert(se.OutPort[*] == @"0b1111_1111");

    se.InPort[*] = @"0";
    simulate();
    assert(se.OutPort[*] == @"0b0000_0000");
end


